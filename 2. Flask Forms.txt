# FLASK FORMS
-------------

* Introduction
--------------
3 min
An important role of websites is gathering information from the user. Whether a user is signing into their Codecademy account, ordering clothes online or leaving feedback for a company, 
web forms have provided a simple way to enter and submit data over the internet.

The use of forms in a site can be an involved process. The designer must gather the right information, display the fields in a pleasing manner and ensure the data is collected correctly. 
Over the years this has become easier thanks to frameworks like Flask, which help streamline the process of displaying fields and gathering data.

This lesson assumes a foundational knowledge of web forms and the steps involved in sending the data to the web server. In the following exercises we are going to look at how Flask can 
help gather data from regular web forms as well as create forms in an entirely new way.

* Instructions
--------------
To help us learn about forms we will be using a cookbook app that lists recipes on a main page and links to individual recipe pages.

	. The main Flask app is contained in app.py and has three routes: index, recipe and about. The index route has method POST added to handle form submission.

	. The file helper.py contains the mock data for the app and has two functions, add_ingredients() and add_instructions() to help populate the data.

	. The main web page is rendered from the template index.html. There is a title, list of recipes and a new recipe form. The form has fields for the recipe name, description, 
	ingredients and instructions.

	. The other template is recipe.html which renders each individual recipe using the mock data.

Review the site structure and head to the next exercise when you’re ready.

index.html
----------
{% extends "base.html" %}
{% block content %}
  <h1>Cooking By Myself</h1>
  <p>Welcome to my cookbook. These are recipes I like.</p>
  {% for id, name in template_recipes.items() %}
    <p><a href="/recipe/{{ id }}">{{ name }}</a></p>
  {% endfor %}

  <form action="/" method="POST">
    <h3>Add Recipe</h3>
    <p>
      <label for="recipe">Name:</label>
      <input type="text" name="recipe"/>
    </p>
    <p>
      <label for="description">Description:</label>
      <textarea name="description"></textarea>
    </p>
    <p>
      <label for="ingredients">Ingredients:</label>
      <textarea name="ingredients"></textarea>
    </p>
    <p>
      <label for="instructions">Instructions:</label>
      <textarea name="instructions"></textarea>
    </p>
    <p><input type="submit" name="submit_recipe"/></p>
  </form>
{% endblock %}

app.py
------
from flask import Flask, render_template
from helper import recipes, descriptions, ingredients, instructions

app = Flask(__name__)

@app.route("/")
def index():
  return render_template("index.html", template_recipes=recipes)

@app.route("/recipe/<int:id>", methods=["GET", "POST"])
def recipe(id):
  return render_template("recipe.html", template_recipe=recipes[id], template_description=descriptions[id], template_ingredients=ingredients[id], template_instructions=instructions[id])

@app.route("/about")
def about():
  return render_template("about.html")

helper.py
---------
recipes = {1: "fried egg", 2: "buttered toast"}
types = {1: "Breakfast", 2: "Breakfast"}
descriptions = {1: "Egg fried in butter", 2: "Toasted bread spread with butter"}
ingredients = {1: ["1 pad of butter", "1 Egg", "A pinch of salt"], 2: ["1 pad of salted butter", "1 slice of bread"]}
instructions = {1: {"Step 2": "Crack the egg into the buttered pan", "Step 5": "Serve egg after about a minute and a half", "Step 1": "Melt butter in pan over medium-low heat", 
		"Step 4": "Flip egg after about a minute and a half", "Step 3": "Sprinke the pinch of salt onto cooking egg",},
                2: {"Step 3": "Put the pad of butter on the toasted bread", "Step 4": "After a minute spread the melted butter onto the bread", "Step 1": "Put the bread in the toaster", 
		"Step 2": "Take the toast out of the toaster"}}
comments = {1: ["Yummy!!", "Egg-cellent ;->"], 2: ["Toasty", "What a great recipe!"]}

def add_ingredients(recipe_id=None, text=None):
  if recipe_id and text:
    text_list = text.split("\n")
    ingredients[recipe_id] = text_list

def add_instructions(recipe_id=None, text=None):
  if recipe_id and text:
    text_list = text.split("\n")
    instructions_dict = {}
    for i, instruction in enumerate(text_list):
      instructions_dict["Step {}".format(i+1)] = instruction

    instructions[recipe_id] = instructions_dict

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Flask Request Object
----------------------
19 min
Every time a client communicates with a server it does so through a request. By default our Flask routes only support GET requests. These are requests for data such as what to display in 
a browser window. When submitting a form through a website, the form data is sent as a POST request. This type of request wants to add data to the app. Routes can handle POST requests if 
it is specified in the methods argument of the route() decorator.

@app.route("/", methods=["GET", "POST"])

The code above shows a route that now supports both GET and POST requests. By default methods is set to [“GET”]. When adding “POST” to a route’s methods, be sure to include “GET” if you 
plan for the route to handle those requests as well.

Flask provides access to the data in the request through the request object. Importing the request object allows us to access everything about the requests to our app including form data 
and the request method such as GET or POST.

from flask import request

When data is sent via a form submission it can be accessed using the form attribute of the request object. The form attribute is a dictionary with the form’s field names as the keys and 
the associated data as the values. For example, if a text input had the name "my_text", then the data access would look like this.

text_in_field = request.form["my_text"]

* Instructions
--------------
Checkpoint 1 Passed
1.
Before we begin with the form data, there are a few additions in the index() function to note regarding the gathering of form data:

	1. The variable new_id is assigned an integer that’s one more than the length of the recipes dictionary we imported form helper.py. This variable will be used as the key for the 
	new recipe data.

	2. The if len(request.form) > 0 statement makes sure there is data in the form object before trying to access them. Without this, a KeyError would be raised when the route is 
	accessed and the form is not submitted.

Review the changes and run the code when you are ready.

Checkpoint 2 Passed
2.
In app.py, note the request object has been added to the import section.

Working in the index route and using the request object, assign the contents of the form’s "recipe" text field to recipes[new_id].

After you run the code feel free to try out your work by refreshing the browser. Keep in mind that not all data is processed yet so clicking on the new recipe links will raise a KeyError.


Hint
Assign data in the field named "recipe" to recipes[new_id] using the following syntax.

some_var = request.form[field_name]

Checkpoint 3 Passed
3.
Repeat the same step for the description form data by assigning the description field data to descriptions[new_id].


Hint
Assign data in the field named "description" to descriptions[new_id] using the following syntax.

some_var = request.form[field_name]

Checkpoint 4 Passed
4.
The helper functions add_ingredients() and add_instructions() are set up to add the contents of the variables new_ingredients and new_instructions to the data. Currently both variables 
are set to None.

Put the form data named "ingredients" and "instructions" into the appropriate variables so the data is added to the app.


Hint
Assign data in the field named "ingredients" to new_ingredients and the data in the field named "instructions" to new_instructions using the following syntax.

some_var = request.form[field_name]

app.py
------
from flask import Flask, render_template, request
from helper import recipes, descriptions, ingredients, instructions, add_ingredients, add_instructions

app = Flask(__name__)

@app.route("/", methods=["GET", "POST"])
def index():
  new_id = len(recipes) + 1
  if len(request.form) > 0:
    #### Add the recipe name to recipes[new_id] 
    recipes[new_id] = request.form["recipe"]
    #### Add the recipe description to descriptions[new_id]
    descriptions[new_id] = request.form["description"]
    #### Add the values to new_ingredients and new_instructions
    new_ingredients = request.form["ingredients"]
    new_instructions = request.form["instructions"]
    add_ingredients(new_id, new_ingredients)
    add_instructions(new_id, new_instructions)
  return render_template("index.html", template_recipes=recipes)

@app.route("/recipe/<int:id>")
def recipe(id):
  return render_template("recipe.html", template_recipe=recipes[id], template_description=descriptions[id], template_ingredients=ingredients[id], template_instructions=instructions[id])

@app.route("/about")
def about():
  return render_template("about.html")

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Route Selection
-----------------
15 min
As sites get larger and their file structure becomes more complex the paths of Flask routes may change. In this case paths that are hard coded into the navigation elements such as 
hyperlinks and forms may break.

Flask addresses the challenge of expanding file structures with url_for(). The function url_for() takes a route’s function name as an argument and returns the associated URL path. Given 
the following Flask route declaration:

@app.route('/')
def index:

These two hyperlinks below are identical.

<a href="/">Index Link</a>

<a href="{{ url_for('index') }}">Index Link</a>

Breaking down the second line of above code, we can see a few things:

	. url_for() is inside an expression delimiter

	. the argument for url_for() is inside single quotes

	. the entire statement is inside double quotes

Because of the last 2 points it is important to use one type of quotes for the whole statement and the other type of quotes for the url_for() argument.

To pass variables from the template to the app, keyword arguments can be added to url_for(). They will be sent as arguments attached to the URL. It can be accessed the same way as if it 
was added onto the path manually.

<a href="{{ url_for('my_page', id=1) }}">One</a>

This line creates a link that sends the value 1 to the route with the function name my_page. The route can access the variable through my_id.

@app.route("/my_path/<int:my_id>"), methods=["GET", "POST"])
def my_page(my_id):
    # Access flask_name in this function
    new_variable = my_id
    ...

* Instructions
--------------
Checkpoint 1 Passed
1.
Let’s look at replacing the URL strings in the navigation bar with url_for().

In base.html replace / with url_for() in the href attribute of the Recipes link. For the argument use the "index" route function name.

Remember to use the double curly brackets when using url_for().


Hint
Use 'index' as the only argument to url_for using the following syntax.

<a href="{{ url_for(route_name) }}">

Checkpoint 2 Passed
2.
Now replace the URL string in the “About” link with url_for() using the about route function name.


Hint
Use 'about' as the only argument to url_for using the following syntax.

<a href="{{ url_for(route_name) }}">

Checkpoint 3 Passed
3.
In index.html the recipe link href is blank. Remember that we want to go to the recipe route and pass the id variable.

Insert url_for() into the blank href attribute passing the correct route function name as well as the id variable.


Hint
Use 'recipe' as the first argument and the keyword assignment id=id as the second to url_for using the following syntax.

<a href="{{ url_for(route_name, flask_var=template_var) }}">

base.html
---------
<!DOCTYPE html>
<html>
  <body>
    <div>
      <!-- Replace URL string with url_for -->
      <a href="{{ url_for('index')}}">Recipes</a>
      | 
      <!-- Replace URL string with url_for -->
      <a href="{{ url_for('about')}}">About</a>
    </div>
    {% block content %}
    {% endblock %}
  </body>
</html>

index.html
----------
{% extends "base.html" %}
{% block content %}
  <h1>Cooking By Myself</h1>
  <p>Welcome to my cookbook. These are recipes I like.</p>
  {% for id, name in template_recipes.items() %}
    <!-- Use url_for to pass the id variable -->
    <p><a href="{{url_for('recipe', id=id)}}">{{ name }}</a></p>
  {% endfor %}

  <form action="/" method="POST">
    <h3>Add Recipe</h3>
    <p>
      <label for="recipe">Name:</label>
      <input type="text" name="recipe"/>
    </p>
    <p>
      <label for="description">Description:</label>
      <textarea name="description"></textarea>
    </p>
    <p>
      <label for="ingredients">Ingredients:</label>
      <textarea name="ingredients"></textarea>
    </p>
    <p>
      <label for="instructions">Instructions:</label>
      <textarea name="instructions"></textarea>
    </p>
    <p><input type="submit" name="submit_recipe"/></p>
  </form>
{% endblock %}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* FlaskForm Class
-----------------
17 min
Flask provides an alternative to web forms by creating a form class in the application, implementing the fields in the template and handling the data back in the application.

A Flask form class inherits from the class FlaskForm and includes attributes for every field:

class MyForm(FlaskForm):
    my_textfield = StringField("TextLabel")
    my_submit = SubmitField("SubmitName")

This simple class will enable the creation of a form with a text field and a submit button.

The class inherits from the class FlaskForm which allows it to implement the form as template variables and then collect the data once submitted. FlaskForm is a part of FlaskWTF.

Access to the fields of this form class is done through the attributes, my_textfield and my_submit. The StringField and SubmitField classes are the same as <input type=text... and <input 
type=submit... respectively and are part of the WTForms library.

Below is a simple Flask app with the form class.

from flask import Flask, render_template
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField

app = Flask(__name__)
app.config["SECRET_KEY"] = "my_secret"

class MyForm(FlaskForm):
    my_textfield = StringField("TextLabel")
    my_submit = SubmitField("SubmitName")

@app.route("/")
def my_route():
    flask_form = MyForm()
    return render_template("my_template", template_form=flask_form)

First note the new import statements. FlaskForm is imported from the flask_wtf module and both form fields import from wtforms.

The next new line is:

app.config["SECRET_KEY"] = "my_secret"

This line is a way to protect against CSRF or Cross-Site Request Forgery. Without going into too much detail, CSRF is an attack that used to gain control of a web application.

Next is the MyForm class definition. It inherits from FlaskForm and has attributes for the text and submit fields. For each field the label is passed as the only argument.

Lastly, in order to use this form in our template, we must create an instance of it and pass it to the template using render_template(). We will look at applying the form in the template 
in the next exercise.

* Instructions
--------------
Checkpoint 1 Passed
1.
In app.py note the extra import statements and the setting of the "SECRET_KEY":

from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField

and

app.config["SECRET_KEY"] = "mysecret"

Other things to note moving forward:

	. The comments dictionary is added to the helper.py import statement

	. methods=["GET", "POST"] has been added to the recipe route

	. The recipe route’s render_template() function call has a new keyword argument template_comments=comments[id]

	. A comments unordered list has been added to the recipe.html template

Take a look at the changes and run the code to move on.

Checkpoint 2 Passed
2.
Above the index route in app.py, create a class called CommentForm that inherits from FlaskForm.

Add a class attribute named comment and assign it a StringField with label "Comment".


Hint
	1. Create a class called CommentForm that inherits from FlaskForm.

	2. Assign a variable comment the StringField object with "Comment" as the only argument.

Use the following syntax.

class some_class(FlaskForm):
  some_stringfield = StringField(label_string)

Checkpoint 3 Passed
3.
Create a submit field inside the class with the label "Add Comment" and assign it to a variable called, submit.


Hint
Assign a variable submit the SubmitField object with "Add Comment" as the only argument using the following syntax.

  some_submitfield = SubmitField(label_string)

Checkpoint 4 Passed
4.
Lastly, in the recipe() route you’ll see that render_template has the argument template_form=comment_form. Just above render_template() create the variable comment_form and assign it an 
instance of CommentForm.


Hint
Instantiate the CommentForm class and assign it to comment_form using the following syntax.

some_form = SomeFormClass()

app.py
------
from flask import Flask, render_template, request
from helper import recipes, descriptions, ingredients, instructions, add_ingredients, add_instructions, comments
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField

app = Flask(__name__)
app.config["SECRET_KEY"] = "mysecret"

#### Create form class here
class CommentForm(FlaskForm):
    comment = StringField("Comment")
    submit = SubmitField("Add Comment")

@app.route("/", methods=["GET", "POST"])
def index():
  return render_template("index.html", template_recipes=recipes)

@app.route("/recipe/<int:id>", methods=["GET", "POST"])
def recipe(id):
  #### Instantiate form class here
  comment_form = CommentForm()
  return render_template("recipe.html", template_recipe=recipes[id], template_description=descriptions[id], template_ingredients=ingredients[id], template_instructions=instructions[id], 
  template_comments=comments[id], template_form=comment_form)

@app.route("/about")
def about():
  return render_template("about.html")


recipe.html
-----------
{% extends "base.html" %}
{% block content %}
  <h1>{{ template_recipe | title }}</h1>
  
  {% if template_description %}
    <p>{{ template_description }}</p>
  {%else%}
    <p>A {{ template_recipe }} recipe.</p>
  {% endif %}
  
  <h3>Ingredients - {{ template_ingredients | length}}</h3>
  <ul>
  {% for ingredient in template_ingredients %}
    <li>{{ ingredient }}</li>
  {% endfor %}
  </ul>

  <h3>Instructions</h3>
  <ul>
  {% for key, instruction in template_instructions|dictsort %}
    <li>{{ instruction }}</li>
  {% endfor %}
  </ul>

  <h3>Comments</h3>
  <ul>
  {% for comment in template_comments %}
    <li>{{ comment }}</li>
  {% endfor %}
  </ul>
{% endblock %}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Template Form Variables
-------------------------
11 min
Creating a form in the template is done by accessing attributes of the form passed to the template.

Let’s use the following form as we work toward implementing it in a template:

class MyForm(FlaskForm):
    my_textfield = StringField("TextLabel")
    my_submit = SubmitField("SubmitName")

In our application route we must instantiate the form and assign that instance to a template variable.

my_form = MyForm()

return render_template(template_form=my_form)

Moving to the template, creating a form we simply use the form class attributes as expressions.

<form action="/" method="post">
    {{ template_form.hidden_tag() }}
    {{ template_form.my_textfield.label }}
    {{ template_form.my_textfield() }}
    {{ template_form.my_submit() }}
</form>

Inside the standard <form> are all the FlaskForm objects accessed through template_form.

The first line {{ template_form.hidden_tag() }} is the other end of the CSRF protection. While not visible in the form, this field handles the necessary tasks to protect from CSRF.

The next two lines are for the text box. The first accesses the label of the field, which we specified as an argument when we created the field. The second my_textfield line is the input 
field itself.

The last line of the form is the submit button. Just like the HTML version, this will initiate sending the form data back to the server.

The HTML created from this form implementation is as follows:

<form action="/" method="post">
    <input id="csrf_token" name="csrf_token" type="hidden" value="ImI1YzIxZjUwZWMxNDg0ZDFiODAyZTY5M2U5MGU3MTg2OThkMTJkZjQi.XupI5Q.9HOwqyn3g2pveEHtJMijTu955NU">
    <label for="my_textfield">TextLabel</label>
    <input id="my_textfield" name="my_textfield" type="text" value="">
    <input id="my_submit" name="my_submit" type="submit" value="SubmitName">
</form>

* Instructions
--------------
Checkpoint 1 Passed
1.
In recipe.html notice the beginning of a form near the bottom of the file. In the form there is a line {{ template_form.hidden_tag() }}. As mentioned this is the other end of the session 
encryption.

On the line following the hidden_tag() statement insert the comment field label.


Hint
Access the comment field label using this syntax.

{{ template_form.comment.label }}

Checkpoint 2 Passed
2.
Now add the comment input field in the following line.


Hint
Access the comment field using this syntax.

{{ template_form.comment() }}

Checkpoint 3 Passed
3.
Finally, add the submit button to complete the form.


Hint
Access the submit field using this syntax.

{{ template_form.submit() }}

recipe.html
-----------
{% extends "base.html" %}
{% block content %}
  <h1>{{ template_recipe | title }}</h1>
  {% if template_description %}
    <p>{{ template_description }}</p>
  {%else%}
    <p>A {{ template_recipe }} recipe.</p>
  {% endif %}
  <h3>Ingredients - {{ template_ingredients | length}}</h3>
  <ul>
  {% for ingredient in template_ingredients %}
      <li>{{ ingredient }}</li>
  {% endfor %}
  </ul>
  <h3>Instructions</h3>
  <ul>
  {% for key, instruction in template_instructions|dictsort %}
      <li>{{ instruction }}</li>
  {% endfor %}
  </ul>
  <h3>Comments</h3>
  <ul>
  {% for comment in template_comments %}
    <li>{{ comment }}</li>
  {% endfor %}
  </ul>
  <form method="POST">
  {{ template_form.hidden_tag() }}
  <!-- Insert StringField elements here -->  
  {{ template_form.comment.label }}
  {{ template_form.comment() }}
  <!-- Insert SubmitField element here -->
  {{ template_form.submit.label }}
  {{ template_form.submit() }}
  </form>
{% endblock %}

app.py
------
from flask import Flask, render_template, request
from helper import recipes, descriptions, ingredients, instructions, add_ingredients, add_instructions, comments
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField

app = Flask(__name__)
app.config["SECRET_KEY"] = "mysecret"

class CommentForm(FlaskForm):
  comment =  StringField("Comment")
  submit = SubmitField("Add Comment")

@app.route("/", methods=["GET", "POST"])
def index():
  return render_template("index.html", template_recipes=recipes)

@app.route("/recipe/<int:id>", methods=["GET", "POST"])
def recipe(id):
  comment_form = CommentForm()
  return render_template("recipe.html", template_recipe=recipes[id], template_description=descriptions[id], template_ingredients=ingredients[id], template_instructions=instructions[id], 
  template_comments=comments[id], template_form=comment_form)

@app.route("/about")
def about():
  return render_template("about.html")

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Handling FlaskForm Data
-------------------------
9 min
Once a form is submitted, the data is sent back to the server through a POST request. Previously we covered accessing this data through the request object provided by Flask.

Using our FlaskForm class, data is now accessible through the form instance in the Flask app. The data can be directly accessed by using the data attribute associated with each field in 
the class.

form_data = flask_form.my_textfield.data

Keeping all the information and functionality attached to the form object has streamlined the form creation and data gathering process.

Remember that when a route handles a form it is necessary to add the POST method to the route decorator.

methods=["GET", "POST"]

* Instructions
--------------
Checkpoint 1 Passed
1.
The data from the web form can now be accessed through the comment_form instance within the recipe route. In that route in app.py assign the comment field data to a variable called 
new_comment.


Hint
Assign comment_form.comment.data to new_comment using this syntax.

some_var = some_instance.some_field.data

Checkpoint 2 Passed
2.
Now add the submitted comment to the specified recipe comment list by appending new_comment to comments[id].

When you’re done, give the form a try by adding some comments to the recipe page. Head on to the next exercise when ready.


Hint
Using .append() add new_comment to the comments[id] list using this syntax.

some_list.append(some_var)

app.py
------
from flask import Flask, render_template, request
from helper import recipes, descriptions, ingredients, instructions, add_ingredients, add_instructions, comments
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField

app = Flask(__name__)
app.config["SECRET_KEY"] = "mysecret"

class CommentForm(FlaskForm):
  comment =  StringField("Comment")
  submit = SubmitField("Add Comment")

@app.route("/", methods=["GET", "POST"])
def index():
  return render_template("index.html", template_recipes=recipes)

@app.route("/recipe/<int:id>", methods=["GET", "POST"])
def recipe(id):
  comment_form = CommentForm()
  #### Process data here
  new_comment = comment_form.comment.data
  comments[id].append(new_comment)
  return render_template("recipe.html", template_recipe=recipes[id], template_description=descriptions[id], template_ingredients=ingredients[id], template_instructions=instructions[id], 
  template_comments=comments[id], template_form=comment_form)

@app.route("/about")
def about():
  return render_template("about.html")

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Validation
------------
11 min
In order to submit a form, it is common that certain required text fields must have data, date fields need to have a specific format, or a checkbox agreeing to certain terms needs to be 
checked.

Validation is when form fields must contain data or a certain format of data in order to move forward with submission. We enable validation in our form class using the validators 
parameter in the form field definitions.

Validators come from the wtform.validators module. Importing the DataRequired() validator is accomplished like this:

from wtforms.validators import DataRequired

The DataRequired() validator simply requires a field to have something in it before the form is submitted. Notifying the user that data is required is handled automatically.

my_textfield = StringField("TextLabel", validators=[DataRequired()])

The validators argument takes a list of validator instances.

The FlaskForm class also provides a method called validate_on_submit(), which we can used in our route to check for a valid form submission.

if my_form.validate_on_submit():
    # get form data

As we saw in the second exercise pertaining to the request object, in order to avoid gathering data on first access to the route we had to put the data gathering code inside an if 
statement. The validate_on_submit() function does this exact task.

The validate_on_submit() function returns True when there is a POST request and all the associated form validators are satisfied. At this point, the data can be gathered and processed. 
When the function returns False the route function can move on to other tasks such as rendering the template.

* Instructions
--------------
Checkpoint 1 Passed
1.
In app.py, the data handling section in the recipe route has been put inside an if True: block to mimic no validation. Run the code and hit refresh on the recipe page and notice what 
happens to the comments list.

Checkpoint 2 Passed
2.
Every time the page refreshes the string “None” is appended to the comments. This is because the data from the form is gathered every time the page renders. Even when the form is not 
submitted.

In app.py add a validate_on_submit() check. Be sure to include the data assignment logic but exclude the form instantiation.


Hint
Create an if statement where the condition is the validate_on_submit method of comment_form. Use the following syntax.

if form_instance.validate_on_submit():

Checkpoint 3 Passed
3.
To ensure that we get a comment every time the button is hit you need to put a validator on the string field. Note the wtforms.validators import statement.

Inside the CommentForm class add a validators list with the validator that requires data.

Run the code, refresh the page and try to submit an empty field. Note that the changes have taken effect


Hint
Add validators=[DataRequired()] to the StringField call.

app.py
------
from flask import Flask, render_template, request
from helper import recipes, descriptions, ingredients, instructions, add_ingredients, add_instructions, comments
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField
#### Note the new import statement
from wtforms.validators import DataRequired

app = Flask(__name__)
app.config["SECRET_KEY"] = "mysecret"

class CommentForm(FlaskForm):
  #### Add a validator argument in the StringField
  comment =  StringField("Comment", validators=[DataRequired()])
  submit = SubmitField("Add Comment")

@app.route("/", methods=["GET", "POST"])
def index():
  return render_template("index.html", template_recipes=recipes)

@app.route("/recipe/<int:id>", methods=["GET", "POST"])
def recipe(id):
  comment_form = CommentForm(csrf_enabled=False)
  #### Replace 'True' with form validation
  if comment_form.validate_on_submit():
    new_comment = comment_form.comment.data
    comments[id].append(new_comment)
  return render_template("recipe.html", template_recipe=recipes[id], template_description=descriptions[id], template_ingredients=ingredients[id], template_instructions=instructions[id], 
template_comments=comments[id], template_form=comment_form)

@app.route("/about")
def about():
  return render_template("about.html")

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* More Form Fields
------------------
18 min
We’ve now covered the operation cycle of forms using FlaskWTF. Now let’s look at some additional form fields included in WTForms.

* TextAreaField
---------------
The TextAreaField is a text field that supports multi-line input. The data returned from a TextAreaField instance is a string that may include more whitespace characters such as newlines 
or tabs.

#### Form class declaration
my_text_area = TextAreaField("Text Area Label")

* BooleanField
--------------
A checkbox element is created using the BooleanField object. The data returned from a BooleanField instance is either True or False.

#### Form class declaration
my_checkbox = BooleanField("Checkbox Label")

* RadioField
------------
A radio button group is created using the RadioField object. Since there are multiple buttons in this group, the instance declaration takes an argument for the group label and a keyword 
argument choices which takes a list of tuples.

Each tuple represents a button in the group and contains the button identifier string and the button label string.

#### Form class declaration
my_radio_group = RadioField("Radio Group Label", choices=[("id1", "One"), ("id2","Two"), ("id3","Three")])

Since the RadioField() instance generally contains multiple buttons it is necessary to iterate through it to access the components of the subfields.

* Instructions
--------------
Checkpoint 1 Passed
1.
A common practice when creating web forms with Flask is to define the forms in a separate file and import them into the main app.

	. CommentForm has been moved to the new file forms.py

	. RecipeForm is fully functional and has been added to forms.py

	. RadioField has been added to the wtforms import statement

	. The list recipe_categories in RecipeForm holds the 3 radio button tuples.

Run the code to move on.

Checkpoint 2 Passed
2.
In forms.py create a radio field instance and assign it to recipe_type. The instance should have the label "Type" and recipe_categories should be assigned to the keyword argument choices.


Hint
Assign a RadioField instance to recipe_type. Be sure to pass the label "Type" as the first argument and choices=recipe_categories as the second argument. Use the following syntax.

some_radio_group = RadioField(label_string, choices=choice_list)

Checkpoint 3 Passed
3.
In index.html a table has been added to contain our radio buttons. Inside the for loop that iterates through the 3 buttons, use the loop variable btn to insert the button field in the 
first <td> tag and the field label in the other <td> tag pair.


Hint
Add btn() to the first <td> statement and btn.label to the second <td> statement. Follow this syntax.

<td>{{ radio_var() }}</td>
<td>{{ radio_var.label }}</td>

Checkpoint 4 Passed
4.
Lastly, in the index route of app.py add the recipe_type data from the form to types[new_id].

When you’re done give the recipe form a try with the new radio buttons.


Hint
Assign recipe_form.recipe_type.data to types[new_id] using this syntax.

some_var = some_instance.some_field.data

forms.py
--------
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField, TextAreaField, RadioField
from wtforms.validators import DataRequired

class RecipeForm(FlaskForm):
  recipe_categories = [("Breakfast","Breakfast"), ("Lunch","Lunch"), ("Dinner","Dinner")]
  recipe = StringField("Recipe", validators=[DataRequired()])  
  #### Add `recipe_type` and assign it a new radio field instance
  recipe_type = RadioField("Type", choices=recipe_categories)
  description = StringField("Description")
  ingredients = TextAreaField("Ingredients")
  instructions = TextAreaField("Instructions")
  submit = SubmitField("Add Recipe")

class CommentForm(FlaskForm):
  comment = StringField("Comment", validators=[DataRequired()])
  submit = SubmitField("Add Comment")

index.html
----------
{% extends "base.html" %}
{% block content %}
  <h1>Cooking By Myself</h1>
  <p>Welcome to my cookbook. These are recipes I like.</p>
  {% for id, name in template_recipes.items() %}
    <p><a href="{{ url_for('recipe', id=id) }}">{{ name }}</a></p>
  {% endfor %}
  <form action="/" method="POST">
    {{ template_form.hidden_tag() }}
    <p>{{ template_form.recipe.label }}
    {{ template_form.recipe() }}</p>
    <table><tr>
      {% for btn in template_form.recipe_type %}
      <!-- Put the button variable then the button label 
      in the following td tags-->
      <td>{{ btn() }}</td>
      <td>{{ btn.label }}</td>
    {% endfor %}
    </tr></table>
    <p>{{ template_form.description.label }}
    {{ template_form.description() }}</p>
    <p>{{ template_form.ingredients.label }}
    {{ template_form.ingredients() }}</p>
    <p>{{ template_form.instructions.label }}
    {{ template_form.instructions() }}</p>
    <p>{{ template_form.submit() }}</p>
  </form>
{% endblock %}

app.py
------
from flask import Flask, render_template, request
from helper import recipes, types, descriptions, ingredients, instructions, add_ingredients, add_instructions, comments
from forms import RecipeForm, CommentForm

app = Flask(__name__)
app.config["SECRET_KEY"] = "mysecret"

@app.route("/", methods=["GET", "POST"])
def index():
  recipe_form = RecipeForm(csrf_enabled=False)
  if recipe_form.validate_on_submit():
    new_id = len(recipes)+1
    recipes[new_id] = recipe_form.recipe.data
    #### Add type data here
    types[new_id] = recipe_form.recipe_type.data
    descriptions[new_id] = recipe_form.description.data
    new_ingredients = recipe_form.ingredients.data
    new_instructions = recipe_form.instructions.data
    add_ingredients(new_id, new_ingredients)
    add_instructions(new_id, new_instructions)
    comments[new_id] = []
  return render_template("index.html", template_recipes=recipes, template_form=recipe_form)

@app.route("/recipe/<int:id>", methods=["GET", "POST"])
def recipe(id):
  comment_form = CommentForm(csrf_enabled=False)
  if comment_form.validate_on_submit():
    new_comment = comment_form.comment.data
    comments[id].append(new_comment)
  return render_template("recipe.html", template_recipe=recipes[id], template_type=types[id], template_description=descriptions[id], template_ingredients=ingredients[id], 
template_instructions=instructions[id], template_comments=comments[id], template_form=comment_form)

@app.route("/about")
def about():
  return render_template("about.html")

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Redirecting
-------------
11 min
Besides rendering templates from our routes, it can be important to move from one route to another. This is the role of the function redirect().

Consider the case where we create our form in one route, but after the form submission we want the user to end up in another route. While we can set the action attribute in the HTML 
<form> tag go to any path, redirect() is the best option to move from one route to another.

redirect("url_string")

Using this function inside another route will simply send us to the URL we specify. In the case of a form submission, we can use redirect() after we have processed and saved our data 
inside our validate_on_submit() check.

Why don’t we just render a different template after processing our form data? There are many reasons for this, one being that each route comes with its own business logic prior to 
rendering its template. Rendering a template outside the initial route would mean you need to repeat some or all of this code.

Once again, to avoid possible URL string pitfalls, we can utilize url_for() within redirect(). This allows us to navigate routes by specifying the route function name instead of the URL 
path.

redirect(url_for("new_route", _external=True, _scheme='https'))

	. we must add two new keyword arguments to our call of url_for()

	. the keyword arguments _external=True and _scheme='https' ensure that the URL we redirect to is a secure HTTPS address and not an insecure HTTP address

Similarly, regular keyword arguments can be added if necessary.

redirect(url_for("new_route", new_var=this_var, _external=True, _scheme='https'))

* Instructions
--------------
Checkpoint 1 Passed
1.
Note the added flask imports: url_for and redirect. These will be used inside our route to change pages after the new recipe form submission.

In the index route of app.py add a return statement still within if recipe_form.validate_on_submit():. Start by returning the path string we want to go to using url_for(). Use the 
"recipe" route function as the main argument and set id to new_id as the keyword argument.

Make sure to set and include the _external and _scheme keyword arguments to load an HTTPS URL.

When submitting a recipe the browser should simply print the correct URL string for the added recipe.


Hint
The return statement should have url_for() with the "recipe" function name as the first argument and id=new_id as the second argument. Use the following syntax.

return url_for("route_function_name", url_var=my_var, _external=True, _scheme='https')

Checkpoint 2 Passed
2.
Now that the URL string is set, let’s add redirect() to the return statement and use the set url_for() as the argument.

When complete, the form submission should change the page to the recipe that was just added. Good work!


Hint
Add redirect() to the return statement and use the existing url_for() function as the only argument. Use the following syntax.

return redirect(url_for("route_function_name", url_var=my_var))

app.py
------
from flask import Flask, render_template, request, redirect, url_for
from helper import recipes, types, descriptions, ingredients, instructions, add_ingredients, add_instructions, comments
from forms import RecipeForm, CommentForm

app = Flask(__name__)
app.config['SECRET_KEY'] = 'mysecret'

@app.route('/', methods=["GET", "POST"])
def index():
  recipe_form = RecipeForm(csrf_enabled=False)
  if recipe_form.validate_on_submit():
    new_id = len(recipes)+1
    recipes[new_id] = recipe_form.recipe.data
    types[new_id] = recipe_form.recipe_type.data
    descriptions[new_id] = recipe_form.description.data
    new_igredients = recipe_form.ingredients.data
    new_instructions = recipe_form.instructions.data
    add_ingredients(new_id, new_igredients)
    add_instructions(new_id, new_instructions)
    comments[new_id] = []
    #### Redirect to recipe route here
    return redirect(url_for("recipe", id=new_id, _external=True, _scheme='https'))
  return render_template("index.html", template_recipes=recipes, template_form=recipe_form)

@app.route("/recipe/<int:id>", methods=["GET", "POST"])
def recipe(id):
  comment_form = CommentForm(csrf_enabled=False)
  if comment_form.validate_on_submit():
    new_comment = comment_form.comment.data
    comments[id].append(new_comment)
  return render_template("recipe.html", template_recipe=recipes[id], template_type=types[id], template_description=descriptions[id], template_ingredients=ingredients[id], 
template_instructions=instructions[id], template_comments=comments[id], template_form=comment_form)

@app.route('/about')
def about():
  return render_template("about.html")

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Review
--------
1 min
In this lesson we learned:

	. How to access form data using the request object

	. Control path selection with route function names using url_for()

	. Create a web form structure using FlaskForm and WTForm fields

	. Create a web form in the templates using FlaskForm variables

	. Utilize field validators for increased data integrity

	. Use redirect() to change paths easily within the app

Being able to utilize Python classes to handle forms is a very efficient process. Organizing form data using the functionality of FlaskWTF and WTForms can be easily achieved.

Navigate through the site and review the files to look at what you accomplished in this lesson.

* Instructions
--------------
Great Work! Explore the app and move on when ready.

































































































































































































































